<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kkokki - Digital Rooster</title>
    <link rel="stylesheet" href="/static/style.css">

    <!-- Leaflet Configuration -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRS9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
</head>

<body>

    <!-- App Container - Mobile Style Layout -->
    <div class="app-container">

        <!-- Top: Search Header -->
        <div class="search-container">
            <div class="search-box">
                <span class="search-icon">ğŸ”</span>
                <input type="text" id="searchInput" class="search-input" placeholder="ì¥ì†Œë¥¼ ê²€ìƒ‰í•˜ì„¸ìš”..."
                    oninput="debounceSearch()" onfocus="onSearchFocus()" onblur="onSearchBlur()" autocomplete="off">
                <span id="searchModeIndicator" class="search-mode-indicator">ì¶œë°œì§€</span>
            </div>
            <!-- Autocomplete Results -->
            <div id="searchResults" class="search-results"></div>
        </div>

        <!-- Center: Map Area -->
        <div class="map-wrapper">
            <div id="map"></div>
            <div class="map-overlay-grid"></div>
        </div>

        <!-- Bottom: Controls & Quest Info -->
        <div class="bottom-controls">

            <!-- Transport Mode Selector -->
            <div class="transport-selector">
                <button class="transport-btn active" onclick="setTransport('car')">
                    <span>ğŸš—</span>
                    <span>CAR</span>
                </button>
                <button class="transport-btn" onclick="setTransport('transit')">
                    <span>ğŸš‡</span>
                    <span>TRANSIT</span>
                </button>
                <button class="transport-btn" onclick="setTransport('walk')">
                    <span>ğŸš¶</span>
                    <span>WALK</span>
                </button>
            </div>

            <!-- Quest Info Card -->
            <div class="quest-card">
                <!-- Pixel Corners -->
                <div class="pixel-corner pc-tl"></div>
                <div class="pixel-corner pc-tr"></div>
                <div class="pixel-corner pc-bl"></div>
                <div class="pixel-corner pc-br"></div>

                <div class="quest-content">
                    <div class="quest-details">
                        <div class="quest-title-row">
                            <span class="quest-title">COMMUTE QUEST</span>
                            <span id="statusBadge" class="live-badge hidden">LIVE</span>
                        </div>

                        <!-- Route Setup UI -->
                        <div class="route-setup">
                            <div class="route-row selecting" id="rowStart" onclick="setSelectionMode('start')">
                                <span class="route-label label-start">START</span>
                                <span id="startDisplay" class="route-value empty">Select on Map...</span>
                            </div>
                            <div class="route-row" id="rowEnd" onclick="setSelectionMode('end')">
                                <span class="route-label label-end">END</span>
                                <span id="endDisplay" class="route-value empty">Select on Map...</span>
                            </div>
                            <button class="swap-btn" onclick="event.stopPropagation(); swapLocations();" title="ì¶œë°œì§€/ë„ì°©ì§€ êµí™˜">
                                â‡…
                            </button>
                        </div>

                        <div class="quest-stat"
                            style="display: flex; align-items: center; justify-content: space-between; margin-top: 10px;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <span>â°</span>
                                <input type="time" id="targetTime" value="09:00"
                                    style="background:transparent; border:1px solid #555; color:white; font-family:'Space Grotesk'; font-size:1rem; padding:2px;">
                            </div>
                            <span style="color:var(--text-muted); font-size:0.8rem;">ARRIVAL TIME</span>
                        </div>

                        <p id="statusText" class="quest-status-text">
                            [START] Mode Active: Click map to set Start Point.
                        </p>
                    </div>

                    <div class="quest-thumbnail">
                        <div id="questThumb" class="thumb-img"
                            style="background-image: url('/static/assets/bg_home_sunny_1769947415146.png')"></div>
                    </div>
                </div>

                <!-- Main Action Button -->
                <button id="mainBtn" class="start-btn" onclick="toggleMonitoring()">
                    <span>START ADVENTURE</span>
                    <span>â–¶ï¸</span>
                </button>
            </div>

        </div>
    </div>

    <!-- Logic Script -->
    <script>
        // State
        let map = null;
        let markers = []; // Search Result Markers
        let routeMarkers = { start: null, end: null }; // Confirmed Start/End Markers
        let routeLines = []; // Lines connecting start and end
        let isRunning = false;
        let transportMode = 'car';
        let searchTimeout = null;

        let selectionMode = 'start'; // 'start' or 'end'
        let hasRoutePreview = false; // Flag to prevent checkStatus from overwriting route info

        // Coordinates store
        let startCoord = null;
        let endCoord = null;

        // Assets
        const THUMB_SUNNY = '/static/assets/bg_home_sunny_1769947415146.png';
        const THUMB_STORMY = '/static/assets/bg_home_stormy_delay_1769947430952.png';

        // Init Map
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Map with OpenStreetMap tiles
            map = L.map('map', {
                zoomControl: false
            });

            // Center on Seoul
            map.setView([37.5665, 126.9780], 13);

            // Add OpenStreetMap tiles (fast and reliable)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                maxZoom: 19
            }).addTo(map);

            // Add zoom control to bottom right
            L.control.zoom({
                position: 'bottomright'
            }).addTo(map);

            // Fix map tiles not loading properly
            setTimeout(() => {
                map.invalidateSize();
                map.setView([37.5665, 126.9780], 13);  // Re-center on Seoul
            }, 200);

            // Additional fix after a longer delay
            setTimeout(() => {
                map.invalidateSize();
            }, 500);

            // Also fix on window resize
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    map.invalidateSize();
                }, 100);
            });

            // Poll status
            setInterval(checkStatus, 2000);
            checkStatus(); // Initial check

            // Close dropdown when clicking map
            map.on('click', (e) => {
                document.getElementById('searchResults').classList.remove('active');
            });

            // Click on map to set location (reverse geocoding)
            map.on('click', async (e) => {
                const lat = e.latlng.lat;
                const lon = e.latlng.lng;
                
                // Create a temporary place object
                const place = {
                    name: `ì„ íƒí•œ ìœ„ì¹˜`,
                    lat: lat,
                    lon: lon,
                    address: `${lat.toFixed(6)}, ${lon.toFixed(6)}`
                };
                
                // Try to get address from reverse geocoding (optional)
                try {
                    const res = await fetch(`/api/reverse-geocode?lat=${lat}&lon=${lon}`);
                    const data = await res.json();
                    if (data.success && data.address) {
                        place.name = data.name || 'ì„ íƒí•œ ìœ„ì¹˜';
                        place.address = data.address;
                    }
                } catch (e) {
                    // Use coordinates if reverse geocoding fails
                }
                
                selectPlace(place);
                
                // Fit map to show the marker
                map.setView([lat, lon], map.getZoom());
            });

            // Focus search input when clicking START/END rows
            document.getElementById('rowStart').addEventListener('click', () => {
                document.getElementById('searchInput').focus();
            });
            document.getElementById('rowEnd').addEventListener('click', () => {
                document.getElementById('searchInput').focus();
            });
        });

        function setSelectionMode(mode) {
            selectionMode = mode;
            hasRoutePreview = false;  // Reset route preview flag

            // Update UI
            document.getElementById('rowStart').classList.remove('selecting');
            document.getElementById('rowEnd').classList.remove('selecting');

            const modeIndicator = document.getElementById('searchModeIndicator');
            const searchInput = document.getElementById('searchInput');

            if (mode === 'start') {
                document.getElementById('rowStart').classList.add('selecting');
                document.getElementById('statusText').innerText = "ì¶œë°œì§€ë¥¼ ê²€ìƒ‰í•˜ê±°ë‚˜ ì§€ë„ì—ì„œ ì„ íƒí•˜ì„¸ìš”";
                modeIndicator.innerText = 'ì¶œë°œì§€';
                modeIndicator.className = 'search-mode-indicator mode-start';
                searchInput.placeholder = 'ì¶œë°œì§€ë¥¼ ê²€ìƒ‰í•˜ì„¸ìš”...';
            } else {
                document.getElementById('rowEnd').classList.add('selecting');
                document.getElementById('statusText').innerText = "ë„ì°©ì§€ë¥¼ ê²€ìƒ‰í•˜ê±°ë‚˜ ì§€ë„ì—ì„œ ì„ íƒí•˜ì„¸ìš”";
                modeIndicator.innerText = 'ë„ì°©ì§€';
                modeIndicator.className = 'search-mode-indicator mode-end';
                searchInput.placeholder = 'ë„ì°©ì§€ë¥¼ ê²€ìƒ‰í•˜ì„¸ìš”...';
            }
        }

        function onSearchFocus() {
            const resultList = document.getElementById('searchResults');
            const query = document.getElementById('searchInput').value;
            
            // Show hint when input is empty
            if (!query || query.length < 2) {
                showSearchHint();
            }
        }

        function onSearchBlur() {
            // Delay to allow click on results
            setTimeout(() => {
                const resultList = document.getElementById('searchResults');
                if (!resultList.matches(':hover')) {
                    resultList.classList.remove('active');
                }
            }, 200);
        }

        function showSearchHint() {
            const resultList = document.getElementById('searchResults');
            resultList.innerHTML = `
                <div class="search-hint">
                    <span>ğŸ’¡</span> ì—­, ê±´ë¬¼ëª…, ì£¼ì†Œë¥¼ ì…ë ¥í•´ë³´ì„¸ìš”
                </div>
            `;
            resultList.classList.add('active');
        }

        function setTransport(mode) {
            transportMode = mode;
            document.querySelectorAll('.transport-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Recalculate route preview with new transport mode
            if (startCoord && endCoord) {
                previewRoute();
            }
        }

        function swapLocations() {
            // Swap coordinates
            const tempCoord = startCoord;
            startCoord = endCoord;
            endCoord = tempCoord;

            // Swap display text
            const startDisplay = document.getElementById('startDisplay');
            const endDisplay = document.getElementById('endDisplay');
            const tempText = startDisplay.innerText;
            const tempClass = startDisplay.classList.contains('empty');
            
            startDisplay.innerText = endDisplay.innerText;
            startDisplay.classList.toggle('empty', endDisplay.classList.contains('empty'));
            
            endDisplay.innerText = tempText;
            endDisplay.classList.toggle('empty', tempClass);

            // Swap markers on map
            if (routeMarkers.start || routeMarkers.end) {
                const tempMarker = routeMarkers.start;
                routeMarkers.start = routeMarkers.end;
                routeMarkers.end = tempMarker;

                // Update marker icons
                if (routeMarkers.start) {
                    routeMarkers.start.setIcon(createPinIcon("START", 'start'));
                }
                if (routeMarkers.end) {
                    routeMarkers.end.setIcon(createPinIcon("END", 'end'));
                }
            }

            // Recalculate route if both points exist
            if (startCoord && endCoord) {
                previewRoute();
            }

            // Visual feedback
            document.querySelector('.swap-btn').classList.add('swapping');
            setTimeout(() => {
                document.querySelector('.swap-btn').classList.remove('swapping');
            }, 300);
        }

        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(performSearch, 500); // 500ms delay
        }

        async function performSearch() {
            const query = document.getElementById('searchInput').value.trim();
            const resultList = document.getElementById('searchResults');

            // Clear temporary search markers first
            markers.forEach(m => map.removeLayer(m));
            markers = [];

            if (!query || query.length < 2) {
                showSearchHint();
                return;
            }

            // Show loading
            resultList.innerHTML = '<div class="search-loading">ğŸ”„ ê²€ìƒ‰ ì¤‘...</div>';
            resultList.classList.add('active');

            try {
                const res = await fetch(`/api/search?keyword=${encodeURIComponent(query)}`);
                const data = await res.json();

                console.log('Search results:', data); // Debug log

                if (!data.results || data.results.length === 0) {
                    resultList.innerHTML = '<div class="search-no-results">ğŸ˜¢ ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                    return;
                }

                // Build result list
                resultList.innerHTML = '';
                const bounds = L.latLngBounds();

                data.results.forEach((place, index) => {
                    // 1. Add marker to Map with numbered icon
                    const iconHtml = `
                        <div class="custom-pin search-result-pin">
                            <div class="pin-body pin-search">
                                <span class="pin-number">${index + 1}</span>
                            </div>
                        </div>
                    `;

                    const customIcon = L.divIcon({
                        html: iconHtml,
                        className: '',
                        iconSize: [30, 30],
                        iconAnchor: [15, 30]
                    });

                    const marker = L.marker([place.lat, place.lon], { icon: customIcon }).addTo(map);
                    marker.on('click', () => selectPlace(place));
                    markers.push(marker);
                    bounds.extend([place.lat, place.lon]);

                    // 2. Add to dropdown list
                    const item = document.createElement('div');
                    item.className = 'search-item';
                    item.innerHTML = `
                        <span class="item-number">${index + 1}</span>
                        <div class="item-content">
                            <strong>${highlightMatch(place.name, query)}</strong>
                            <small>${place.address || 'ì£¼ì†Œ ì •ë³´ ì—†ìŒ'}</small>
                        </div>
                        <span class="item-select-hint">${selectionMode === 'start' ? 'ì¶œë°œ' : 'ë„ì°©'}</span>
                    `;
                    item.addEventListener('click', () => {
                        selectPlace(place);
                        map.setView([place.lat, place.lon], 16);
                    });
                    resultList.appendChild(item);
                });

                // Keep existing route points in view too
                if (routeMarkers.start) bounds.extend(routeMarkers.start.getLatLng());
                if (routeMarkers.end) bounds.extend(routeMarkers.end.getLatLng());

                if (bounds.isValid()) {
                    map.fitBounds(bounds, { padding: [50, 200] });
                }

            } catch (error) {
                console.error('Search error:', error);
                resultList.innerHTML = '<div class="search-no-results">âš ï¸ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</div>';
            }
        }

        // Highlight matching text in search results
        function highlightMatch(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        function createPinIcon(label, type) {
            const extraClass = type === 'start' ? 'pin-start' : 'pin-end';
            const emoji = type === 'start' ? 'ğŸš€' : 'ğŸ';
            const iconHtml = `
                    <div class="custom-pin ${extraClass}">
                        <div class="pin-body">
                            <span style="font-size:14px">${emoji}</span>
                        </div>
                        <div class="pin-label">${label}</div>
                    </div>
                `;
            return L.divIcon({
                html: iconHtml,
                className: '',
                iconSize: [40, 40],
                iconAnchor: [20, 40]
            });
        }

        function selectPlace(place) {
            document.getElementById('searchResults').classList.remove('active');
            document.getElementById('searchInput').value = '';

            if (selectionMode === 'start') {
                // Set Start
                startCoord = place;
                document.getElementById('startDisplay').innerText = place.name;
                document.getElementById('startDisplay').classList.remove('empty');

                if (routeMarkers.start) map.removeLayer(routeMarkers.start);

                routeMarkers.start = L.marker([place.lat, place.lon], {
                    icon: createPinIcon("START", 'start'),
                    zIndexOffset: 1000
                }).addTo(map);

                // Add popup with place info
                routeMarkers.start.bindPopup(`<b>ì¶œë°œì§€</b><br>${place.name}<br><small>${place.address || ''}</small>`);

                // Fly to the selected location
                map.flyTo([place.lat, place.lon], 15, { duration: 0.5 });

                // Auto-switch to End selection and focus search
                setSelectionMode('end');
                setTimeout(() => {
                    document.getElementById('searchInput').focus();
                }, 600);

            } else {
                // Set End
                endCoord = place;
                document.getElementById('endDisplay').innerText = place.name;
                document.getElementById('endDisplay').classList.remove('empty');

                if (routeMarkers.end) map.removeLayer(routeMarkers.end);

                routeMarkers.end = L.marker([place.lat, place.lon], {
                    icon: createPinIcon("END", 'end'),
                    zIndexOffset: 1000
                }).addTo(map);

                // Add popup with place info
                routeMarkers.end.bindPopup(`<b>ë„ì°©ì§€</b><br>${place.name}<br><small>${place.address || ''}</small>`);
            }

            // Preview route if both points are set
            if (startCoord && endCoord) {
                previewRoute();
            }

            // Clear search markers
            markers.forEach(m => map.removeLayer(m));
            markers = [];

            // Draw/Update line connecting start and end
            updateRouteLine();

            // Fit bounds to show both markers (only when both are set)
            if (routeMarkers.start && routeMarkers.end) {
                const bounds = L.latLngBounds();
                bounds.extend(routeMarkers.start.getLatLng());
                bounds.extend(routeMarkers.end.getLatLng());
                
                setTimeout(() => {
                    map.fitBounds(bounds, { padding: [80, 80], maxZoom: 14 });
                }, 300);
            }
        }

        function updateRouteLine() {
            // Remove existing lines
            routeLines.forEach(line => map.removeLayer(line));
            routeLines = [];

            // Draw line only if both start and end are set
            if (routeMarkers.start && routeMarkers.end) {
                const startLatLng = routeMarkers.start.getLatLng();
                const endLatLng = routeMarkers.end.getLatLng();

                // Create main dashed line
                const mainLine = L.polyline([startLatLng, endLatLng], {
                    color: '#eea02b',
                    weight: 4,
                    opacity: 0.8,
                    dashArray: '10, 10',
                    lineCap: 'round'
                }).addTo(map);
                routeLines.push(mainLine);

                // Add inner white line for better visibility
                const innerLine = L.polyline([startLatLng, endLatLng], {
                    color: '#fff',
                    weight: 2,
                    opacity: 0.4,
                    dashArray: '5, 15',
                    lineCap: 'round'
                }).addTo(map);
                routeLines.push(innerLine);
            }
        }

        async function toggleMonitoring() {
            if (isRunning) {
                // Stop
                if (!confirm("Abort Mission?")) return;
                await fetch('/api/stop', { method: 'POST' });
                checkStatus();
            } else {
                // Start
                if (!startCoord || !endCoord) {
                    alert("ì¶œë°œì§€ì™€ ë„ì°©ì§€ë¥¼ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”!");
                    return;
                }

                const targetTime = document.getElementById('targetTime').value;
                if (!targetTime) {
                    alert("ë„ì°© ì‹œê°„ì„ ì„¤ì •í•´ì£¼ì„¸ìš”!");
                    return;
                }

                // Map transport mode (UI uses 'subway' but API expects 'transit')
                const apiTransport = transportMode;

                // Send Coordinates Object with transport mode
                await fetch('/api/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        start: startCoord,
                        end: endCoord,
                        time: targetTime,
                        transport: apiTransport
                    })
                });

                isRunning = true;
                document.getElementById('mainBtn').classList.add('active');
                document.getElementById('mainBtn').innerHTML = `<span>ABORT MISSION</span><span>â¹ï¸</span>`;

                // Switch status to "Calculating..."
                document.getElementById('statusText').innerText = "ê²½ë¡œ ê³„ì‚° ì¤‘...";
            }
        }

        // Calculate and display route preview when both points are set
        async function previewRoute() {
            if (!startCoord || !endCoord) return;

            const apiTransport = transportMode;
            document.getElementById('statusText').innerText = "ğŸ”„ ê²½ë¡œ ê³„ì‚° ì¤‘...";

            try {
                const res = await fetch('/api/route', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        start: startCoord,
                        end: endCoord,
                        transport: apiTransport
                    })
                });

                const data = await res.json();
                console.log('Route data:', data);

                if (data.success && data.route) {
                    const route = data.route;
                    let statusMsg = '';
                    
                    if (route.mode === 'transit') {
                        // ëŒ€ì¤‘êµí†µ: ì‹œê°„, ìš”ê¸ˆ, í™˜ìŠ¹íšŸìˆ˜, ë„ë³´ì‹œê°„ í‘œì‹œ
                        statusMsg = `ğŸš‡ ${route.minutes}ë¶„`;
                        if (route.fare) statusMsg += ` | ${route.fare.toLocaleString()}ì›`;
                        if (route.transfers !== undefined) statusMsg += ` | í™˜ìŠ¹ ${route.transfers}íšŒ`;
                        if (route.walk_minutes) statusMsg += ` | ë„ë³´ ${route.walk_minutes}ë¶„`;
                        if (route.path_type) statusMsg += ` (${route.path_type})`;
                    } else if (route.mode === 'walk') {
                        // ë„ë³´: ì‹œê°„, ê±°ë¦¬ í‘œì‹œ
                        statusMsg = `ğŸš¶ ${route.minutes}ë¶„ | ${route.distance}km`;
                    } else {
                        // ìë™ì°¨: ì‹œê°„, ê±°ë¦¬ í‘œì‹œ
                        statusMsg = `ğŸš— ${route.minutes}ë¶„ | ${route.distance}km`;
                    }
                    
                    document.getElementById('statusText').innerText = statusMsg;
                    hasRoutePreview = true;  // Prevent checkStatus from overwriting
                    
                    // Store route info for later
                    window.currentRoute = route;
                } else {
                    // Check for specific error types
                    let errorMsg = "âš ï¸ ê²½ë¡œ ê³„ì‚° ì‹¤íŒ¨";
                    if (data.error) {
                        if (data.error.includes("429") || data.error.includes("QUOTA") || data.error.includes("Limit")) {
                            errorMsg = "âš ï¸ API í˜¸ì¶œ í•œë„ ì´ˆê³¼ - ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”";
                        } else {
                            errorMsg = "âš ï¸ " + data.error;
                        }
                    }
                    document.getElementById('statusText').innerText = errorMsg;
                    hasRoutePreview = false;
                }
            } catch (error) {
                console.error('Route preview error:', error);
                document.getElementById('statusText').innerText = "âš ï¸ ê²½ë¡œ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ";
                hasRoutePreview = false;
            }
        }

        async function checkStatus() {
            try {
                const res = await fetch('/api/status');
                const data = await res.json();

                isRunning = data.is_running;
                const btn = document.getElementById('mainBtn');
                const badge = document.getElementById('statusBadge');
                const statusText = document.getElementById('statusText');
                const thumb = document.getElementById('questThumb');

                if (isRunning) {
                    btn.classList.add('stop-btn');
                    btn.innerHTML = '<span>ABORT MISSION</span><span>â¹ï¸</span>';
                    badge.classList.remove('hidden');
                    hasRoutePreview = false;

                    // Live Logic - Show wake up time breakdown
                    if (data.latest_result) {
                        const r = data.latest_result;
                        
                        if (r.is_late) {
                            statusText.innerHTML = `
                                <div style="color:#e63946;font-weight:bold;">ğŸš¨ ì§€ê° ìœ„í—˜! ${r.delay}ë¶„ ëŠ¦ìŒ</div>
                                <div style="margin-top:4px;">â° ê¸°ìƒ: ${r.wake_up_time} | ğŸšª ì¶œë°œ: ${r.leave_time} | ğŸ ë„ì°©: ${r.arrival_time}</div>
                            `;
                            thumb.style.backgroundImage = `url('${THUMB_STORMY}')`;
                        } else {
                            statusText.innerHTML = `
                                <div style="color:#2a9d8f;font-weight:bold;">â° ê¸°ìƒ ì‹œê°„: ${r.wake_up_time}</div>
                                <div style="font-size:0.75rem;margin-top:4px;color:#b9ae9d;">
                                    ì¤€ë¹„ ${r.prep_time}ë¶„ + ì´ë™ ${r.travel_time}ë¶„ + ì—¬ìœ  ${r.buffer_time}ë¶„
                                </div>
                                <div style="font-size:0.75rem;color:#b9ae9d;">
                                    ğŸšª ì¶œë°œ: ${r.leave_time} â†’ ğŸ ë„ì°©: ${r.arrival_time}
                                </div>
                            `;
                            thumb.style.backgroundImage = `url('${THUMB_SUNNY}')`;
                        }
                    } else {
                        statusText.innerText = data.status || "ê²½ë¡œ ê³„ì‚° ì¤‘...";
                    }
                } else {
                    btn.classList.remove('stop-btn');
                    btn.innerHTML = '<span>START ADVENTURE</span><span>â–¶ï¸</span>';
                    badge.classList.add('hidden');
                    
                    // Don't overwrite route preview with default status
                    if (!hasRoutePreview) {
                        statusText.innerText = data.status || "Ready for assignment.";
                        statusText.style.color = '#b9ae9d';
                    }
                }

            } catch (e) {
                console.error(e);
            }
        }

    </script>
</body>

</html>